#!/bin/bash
# REF: https://github.com/cedric-dufour/scriptisms/blob/master/system/openssl-easy
SCRIPT="${0##*/}"
VERSION='1.0.20221028a'
umask 077
shopt -s extglob


## Helpers
function _INFO {
  echo "INFO[${SCRIPT}${ARG_COMMAND:+:${ARG_COMMAND}}]: ${1}"
  return 0
}
function _NOTICE {
  echo "NOTICE[${SCRIPT}${ARG_COMMAND:+:${ARG_COMMAND}}]: ${1}"
  return 0
}
function _WARNING {
  echo "WARNING[${SCRIPT}${ARG_COMMAND:+:${ARG_COMMAND}}]: ${1}" >&2
  return 0
}
function _ERROR {
  echo "ERROR[${SCRIPT}${ARG_COMMAND:+:${ARG_COMMAND}}]: ${1}" >&2
  return 0
}


## Defaults
DFLT_ROOT="${OPENSSL_ROOT:-.}"
DFLT_CONF="${OPENSSL_CONF:-${DFLT_ROOT}/openssl.conf}"
DFLT_DIR_CA="${DFLT_ROOT}/CA"
DFLT_DIR_CA_CERTS="${DFLT_DIR_CA}/certs"
DFLT_FILE_CA_KEY="${DFLT_DIR_CA}/key.pem"
DFLT_FILE_CA_CERT="${DFLT_DIR_CA}/cert.pem"
DFLT_FILE_CA_DATABASE="${DFLT_DIR_CA}/database"
DFLT_FILE_CA_SERIAL="${DFLT_DIR_CA}/serial"
DFLT_FILE_CA_CRLNUMBER="${DFLT_DIR_CA}/crlnumber"
DFLT_FILE_CA_ATTNS="${DFLT_DIR_CA}/attns.pem"
DFLT_DIR_KEYS="${DFLT_ROOT}/keys"
DFLT_DIR_PUBS="${DFLT_ROOT}/pubs"
DFLT_DIR_ATTNS="${DFLT_ROOT}/attns"
DFLT_DIR_REQS="${DFLT_ROOT}/reqs"
DFLT_DIR_CERTS="${DFLT_ROOT}/certs"
DFLT_DIR_CRLS="${DFLT_ROOT}/crls"
DFLT_FILE_DATABASE="${DFLT_ROOT}/database"
DFLT_DATE="$(date +'%Y%m%d')"
DFLT_ALGO_PKI='rsa'
DFLT_ALGO_WRAP='aes256'
DFLT_ALGO_MAC='sha256'
DFLT_KEY_LENGTH='2048'
DFLT_KEY_CURVE='prime256v1'


## Source invocation ?
if [ "${BASH_LINENO[0]}" -ne 0 ]; then
  case "${1}" in
    'set-key-passwd')
      read -r -s -p "Private key password: " p1 && echo
      read -r -s -p "Private key password (confirm): " p2 && echo
      [ "${p1}" != "${p2}" ] && _ERROR 'Password/confirmation mismatch' && return 1
      export OPENSSL_PASSWORD="${p1}"
      _INFO 'Private key password successfully set (OPENSSL_PASSWORD)'
      unset p1 p2
      ;;
    'set-ca-passwd')
      read -r -s -p "CA (private key) password: " p1 && echo
      read -r -s -p "CA (private key) password (confirm): " p2 && echo
      [ "${p1}" != "${p2}" ] && _ERROR 'Password/confirmation mismatch' && return 1
      export OPENSSL_PASSWORD_CA="${p1}"
      _INFO 'CA (private key) password successfully set (OPENSSL_PASSWORD_CA)'
      unset p1 p2
      ;;
  esac
  return 0
fi


## OpenSSL variant/version
read -r OPENSSL_VARIANT OPENSSL_VERSION _ < <(openssl version)


## Usage
function _help {
cat >&2 << EOF
USAGE: ${SCRIPT} <command> [options]

SYNOPSIS:
  An easy wrapper for everyday-use of OpenSSL

COMMANDS:

  Certification Authority (CA) management
    -> ${SCRIPT} help-ca

  Private keys management
    -> ${SCRIPT} help-key

  Public keys management
    -> ${SCRIPT} help-pub

  Attestations (certificate; ATTN) management
    -> ${SCRIPT} help-attn

  Certificate Signing Requests (CSR) management
    -> ${SCRIPT} help-req

  Certificates management
    -> ${SCRIPT} help-cert

  Certificate Revocation List (CRL) management
    -> ${SCRIPT} help-crl

  PKCS#11 integration (private key)
    -> ${SCRIPT} help-pkcs11

  Prompt for and store the (CA) private key password
    -> source ${SCRIPT} set-ca-passwd
    -> source ${SCRIPT} set-key-passwd

GLOBAL OPTIONS:

  +id <ID>
    File identifier, used to prefix files

  +date <YYYYMMDD>
    Generation date, used to suffix files (default: ${DFLT_DATE})

  +verbose
    Output detailed information about imported/created material

  +auto
    Automatically create missing dependencies (priv. key and/or cert. signing request)
    WARNING: the same options are passed to all commands ('make-key' and/or 'make-req')

  -...
    Option passed "as is" to OpenSSL

ENVIRONMENT:

  OPENSSL_ROOT=${DFLT_ROOT}
    Path to the working directory, where all OpenSSL material is stored

  OPENSSL_CONF=${DFLT_CONF}
    Path to the OpenSSL configuration file

  OPENSSL_PASSWORD, OPENSSL_PASSWORD_CA
    (CA) Private key password

  OPENSSL_DN_{ORGANIZATIONALUNIT,COMMONNAME,EMAILADDRESS,TITLE}
    Certificate distinguished name (DN) components

  OPENSSL_EXT_SAN
    Certificate subject alternative names (SAN)
EOF
}

# Environment
export OPENSSL_ROOT="${DFLT_ROOT}"
export OPENSSL_CONF="${DFLT_CONF}"
export OPENSSL_DIR_CA="${DFLT_DIR_CA}"
export OPENSSL_DIR_CA_CERTS="${DFLT_DIR_CA_CERTS}"
export OPENSSL_FILE_CA_KEY="${DFLT_FILE_CA_KEY}"
export OPENSSL_FILE_CA_CERT="${DFLT_FILE_CA_CERT}"
export OPENSSL_FILE_CA_DATABASE="${DFLT_FILE_CA_DATABASE}"
export OPENSSL_FILE_CA_SERIAL="${DFLT_FILE_CA_SERIAL}"
export OPENSSL_FILE_CA_CRLNUMBER="${DFLT_FILE_CA_CRLNUMBER}"
export OPENSSL_FILE_CA_ATTNS="${DFLT_FILE_CA_ATTNS}"
export OPENSSL_DIR_KEYS="${DFLT_DIR_KEYS}"
export OPENSSL_DIR_PUBS="${DFLT_DIR_PUBS}"
export OPENSSL_DIR_ATTNS="${DFLT_DIR_ATTNS}"
export OPENSSL_DIR_REQS="${DFLT_DIR_REQS}"
export OPENSSL_DIR_CERTS="${DFLT_DIR_CERTS}"
export OPENSSL_DIR_CRLS="${DFLT_DIR_CRLS}"
export OPENSSL_FILE_DATABASE="${DFLT_FILE_DATABASE}"
export OPENSSL_ALGO_WRAP="${DFLT_ALGO_WRAP}"
export OPENSSL_ALGO_MAC="${DFLT_ALGO_MAC}"

# Arguments
ARG_COMMAND=
ARG_1=
OPTS=()
OPT_ID=
OPT_DATE=
OPT_ALGO_PKI="${OPENSSL_ALGO_PKI:-${DFLT_ALGO_PKI}}"
OPT_KEY_LENGTH="${OPENSSL_KEY_LENGTH:-${DFLT_KEY_LENGTH}}"
OPT_KEY_CURVE="${OPENSSL_KEY_CURVE:-${DFLT_KEY_CURVE}}"
OPT_PKCS11_TOKEN="${OPENSSL_PKCS11_TOKEN}"
OPT_PKCS11_OBJECT="${OPENSSL_PKCS11_OBJECT}"
OPT_PKCS11_ID="${OPENSSL_PKCS11_ID}"
OPT_DN_COMMONNAME="${OPENSSL_DN_COMMONNAME}"
OPT_DN_EMAILADDRESS="${OPENSSL_DN_EMAILADDRESS}"
OPT_DN_ORGANIZATIONALUNIT="${OPENSSL_DN_ORGANIZATIONALUNIT}"
OPT_DN_TITLE="${OPENSSL_DN_TITLE}"
OPT_EXT_SAN="${OPENSSL_EXT_SAN}"
OPT_CHAIN=()
OPT_LIST_VALID=
OPT_LIST_EXPIRED=
OPT_LIST_REVOKED=
OPT_VERBOSE="${OPENSSL_VERBOSE}"
OPT_AUTO=
OPT_OPENSSL=
while [ -n "${1}" ]; do
  case "${1}" in

    '+id'|'+date')
      [ -z "${2}" ] && _ERROR "Missing option argument ($1)" && exit 1
      OPTS+=("${1}" "${2}")
      case "${1}" in
        '+id') OPT_ID="${2}";;
        '+date') OPT_DATE="${2}";;
      esac
      shift
      ;;

    '+algorithm'|'+length'|'+curve'|'+pkcs11-token'|'+pkcs11-object'|'+pkcs11-id'|'+name'|'+email'|'+unit'|'+title'|'+san-'*|'+chain')
      [ -z "${2}" ] && _ERROR "Missing option argument ($1)" && exit 1
      case "${1}" in
        '+algorithm') OPT_ALGO_PKI="${2,,}";;
        '+length') OPT_KEY_LENGTH="${2}";;
        '+curve') OPT_KEY_CURVE="${2}";;
        '+pkcs11-token') OPT_PKCS11_TOKEN="${2}";;
        '+pkcs11-object') OPT_PKCS11_OBJECT="${2}";;
        '+pkcs11-id') OPT_PKCS11_ID="${2}";;
        '+name') OPT_DN_COMMONNAME="${2}";;
        '+email') OPT_DN_EMAILADDRESS="${2}";;
        '+unit') OPT_DN_ORGANIZATIONALUNIT="${2}";;
        '+title') OPT_DN_TITLE="${2}";;
        '+san-dns') OPT_EXT_SAN="${OPT_EXT_SAN:+${OPT_EXT_SAN},}DNS:${2}";;
        '+san-uri') OPT_EXT_SAN="${OPT_EXT_SAN:+${OPT_EXT_SAN},}URI:${2}";;
        '+san-ip') OPT_EXT_SAN="${OPT_EXT_SAN:+${OPT_EXT_SAN},}IP:${2}";;
        '+san-rid') OPT_EXT_SAN="${OPT_EXT_SAN:+${OPT_EXT_SAN},}RID:${2}";;
        '+san-dir') OPT_EXT_SAN="${OPT_EXT_SAN:+${OPT_EXT_SAN},}dirName:${2}";;
        '+san-email') OPT_EXT_SAN="${OPT_EXT_SAN:+${OPT_EXT_SAN},}email:${2}";;
        '+san-other') OPT_EXT_SAN="${OPT_EXT_SAN:+${OPT_EXT_SAN},}otherName:${2}";;
        '+san-'*) _ERROR "Invalid subject alternative name (SAN) extension (${1})" && exit 1;;
        '+chain') OPT_CHAIN+=("${2}");;
      esac
      shift
      ;;

    '+valid'|'+expired'|'+revoked'|'+verbose'|'+auto')
      OPTS+=("${1}")
      case "${1}" in
        '+valid') OPT_LIST_VALID='yes';;
        '+expired') OPT_LIST_EXPIRED='yes';;
        '+revoked') OPT_LIST_REVOKED='yes';;
        '+verbose') OPT_VERBOSE='yes';;
        '+auto') OPT_AUTO='yes';;
      esac
      ;;

    'version'|'+version'|'--version')
      echo "${SCRIPT} ${VERSION} (${OPENSSL_VARIANT} ${OPENSSL_VERSION})" && exit 0
      ;;

    'help'|'+help'|'--help')
      _help && exit 1
      ;;

    +*)
      _ERROR "Invalid option (${1})" && exit 1
      ;;

    -*)
      OPTS+=("${1}")
      if [ "${2:0:1}" == '-' ]; then
        OPT_OPENSSL="${OPT_OPENSSL:+${OPT_OPENSSL} }${1}"
      else
        OPTS+=("${2}")
        OPT_OPENSSL="${OPT_OPENSSL:+${OPT_OPENSSL} }${1} ${2}"
        shift
      fi
      ;;

    *)
      if [ -z "${ARG_COMMAND}" ]; then
        ARG_COMMAND="${1}"
      elif [ -z "${ARG_1}" ]; then
        ARG_1="${1}"
      else
        _ERROR "Too many arguments (${1})" && exit 1
      fi
      ;;

  esac
  shift
done
export OPENSSL_ALGO_PKI="${OPT_ALGO_PKI}"
export OPENSSL_KEY_LENGTH="${OPT_KEY_LENGTH}"
export OPENSSL_KEY_CURVE="${OPT_KEY_CURVE}"
export OPENSSL_PKCS11_TOKEN="${OPT_PKCS11_TOKEN}"
export OPENSSL_PKCS11_OBJECT="${OPT_PKCS11_OBJECT}"
export OPENSSL_PKCS11_ID="${OPT_PKCS11_ID}"
export OPENSSL_DN_COMMONNAME="${OPT_DN_COMMONNAME}"
export OPENSSL_DN_EMAILADDRESS="${OPT_DN_EMAILADDRESS}"
export OPENSSL_DN_ORGANIZATIONALUNIT="${OPT_DN_ORGANIZATIONALUNIT}"
export OPENSSL_DN_TITLE="${OPT_DN_TITLE}"
export OPENSSL_EXT_SAN="${OPT_EXT_SAN}"
export OPENSSL_VERBOSE="${OPT_VERBOSE}"


## Environment

# Checks
[ ! -d "${OPENSSL_ROOT}" ] && _ERROR "Missing OpenSSL root directory (OPENSSL_ROOT=${OPENSSL_ROOT})"  && exit 1
[ ! -r "${OPENSSL_CONF}" ] && _ERROR "Missing/unreadable OpenSSL configuration (OPENSSL_CONF=${OPENSSL_CONF})"  && exit 1
[ ! -e "${OPENSSL_DIR_KEYS}" ] && mkdir "${OPENSSL_DIR_KEYS}"
{ [ ! -d "${OPENSSL_DIR_KEYS}" ] || [ ! -w "${OPENSSL_DIR_KEYS}" ]; } && _ERROR "Invalid/unwritable private keys directory (${OPENSSL_DIR_KEYS})"  && exit 1
[ ! -e "${OPENSSL_DIR_PUBS}" ] && mkdir "${OPENSSL_DIR_PUBS}"
{ [ ! -d "${OPENSSL_DIR_PUBS}" ] || [ ! -w "${OPENSSL_DIR_PUBS}" ]; } && _ERROR "Invalid/unwritable public keys directory (${OPENSSL_DIR_PUBS})"  && exit 1
[ ! -e "${OPENSSL_DIR_ATTNS}" ] && mkdir "${OPENSSL_DIR_ATTNS}"
{ [ ! -d "${OPENSSL_DIR_ATTNS}" ] || [ ! -w "${OPENSSL_DIR_ATTNS}" ]; } && _ERROR "Invalid/unwritable attestations directory (${OPENSSL_DIR_ATTNS})"  && exit 1
[ ! -e "${OPENSSL_DIR_REQS}" ] && mkdir "${OPENSSL_DIR_REQS}"
{ [ ! -d "${OPENSSL_DIR_REQS}" ] || [ ! -w "${OPENSSL_DIR_REQS}" ]; } && _ERROR "Invalid/unwritable certificate signing requests directory (${OPENSSL_DIR_REQS})"  && exit 1
[ ! -e "${OPENSSL_DIR_CERTS}" ] && mkdir "${OPENSSL_DIR_CERTS}"
{ [ ! -d "${OPENSSL_DIR_CERTS}" ] || [ ! -w "${OPENSSL_DIR_CERTS}" ]; } && _ERROR "Invalid/unwritable signed certificates directory (${OPENSSL_DIR_CERTS})"  && exit 1
[ ! -e "${OPENSSL_DIR_CRLS}" ] && mkdir "${OPENSSL_DIR_CRLS}"
{ [ ! -d "${OPENSSL_DIR_CRLS}" ] || [ ! -w "${OPENSSL_DIR_CRLS}" ]; } && _ERROR "Invalid/unwritable certificate revocation lists directory (${OPENSSL_DIR_CRLS})"  && exit 1


## Helpers (cont'd)

# PKCS#11
function _rfc7512_pchar() {
  # REF: https://tools.ietf.org/html/rfc7512#section-2.3
  # REF: https://tools.ietf.org/html/rfc3986#section-2.2
  # REF: https://stackoverflow.com/questions/296536/how-to-urlencode-data-for-curl-command
  local string="${1}"
  local strlen=${#string}
  local encoded=
  local pos c o

  for (( pos=0; pos<strlen; pos++ )); do
    c="${string:$pos:1}"
    case "${c}" in
      [-_.~a-zA-Z0-9]) o="${c}" ;;
      *) printf -v o '%%%02X' "'${c}" ;;
     esac
     encoded+="${o}"
  done
  echo "${encoded}"
}
function _rfc7512_hexnum() {
  local string; string="$(printf '%x' "0x${1}")"
  local strlen=${#string}
  local encoded=
  local pos o

  for (( pos=strlen-2; pos>=0; pos-=2 )); do
    c="${string:$pos:2}"
    printf -v o '%%%02X' "0x${c}"
    encoded="${o}${encoded}"
  done
  if [ "${pos}" -eq -1 ]; then
    c="${string:0:1}"
    printf -v o '%%%02X' "0x${c}"
    encoded="${o}${encoded}"
  fi
  echo "${encoded}"
}
OPT_PKCS11_URI=
if [ -n "${OPT_PKCS11_TOKEN}" ] || [ -n "${OPT_PKCS11_OBJECT}" ] || [ -n "${OPT_PKCS11_ID}" ]; then
  OPT_PKCS11_URI='pkcs11:type=private'
  [ -n "${OPT_PKCS11_TOKEN}" ] && OPT_PKCS11_URI="${OPT_PKCS11_URI};token=$(_rfc7512_pchar "${OPT_PKCS11_TOKEN}")"
  [ -n "${OPT_PKCS11_OBJECT}" ] && OPT_PKCS11_URI="${OPT_PKCS11_URI};object=$(_rfc7512_pchar "${OPT_PKCS11_OBJECT}")"
  [ -n "${OPT_PKCS11_ID}" ] && OPT_PKCS11_URI="${OPT_PKCS11_URI};id=$(_rfc7512_hexnum "${OPT_PKCS11_ID}")"
fi

# OpenSSL configuration quirks
function _openssl_conf_quirks() {
  TMP_CONF="$(mktemp)" || exit 1
  # shellcheck disable=SC2064
  trap "rm -f '${TMP_CONF}'" EXIT
  cat "${OPENSSL_CONF}" > "${TMP_CONF}"
  [ -z "${OPENSSL_DN_COMMONNAME}" ] && sed -i'' -e 's/^\(\(commonName\|CN\)[^a-z]*ENV::OPENSSL_DN_COMMONNAME\)/#\1/i' "${TMP_CONF}"
  [ -z "${OPENSSL_DN_EMAILADDRESS}" ] && sed -i'' -e 's/^\(emailAddress[^a-z]*ENV::OPENSSL_DN_EMAILADDRESS\)/#\1/i' "${TMP_CONF}"
  [ -z "${OPENSSL_DN_ORGANIZATIONALUNIT}" ] && sed -i'' -e 's/^\(\(organizationalUnitName\|OU\)[^a-z]*ENV::OPENSSL_DN_ORGANIZATIONALUNIT\)/#\1/i' "${TMP_CONF}"
  [ -z "${OPENSSL_DN_TITLE}" ] && sed -i'' -e 's/^\(title[^a-z]*ENV::OPENSSL_DN_TITLE\)/#\1/i' "${TMP_CONF}"
  [ -z "${OPENSSL_EXT_SAN}" ] && sed -i'' -e 's/^\(subjectAltName[^a-z]*ENV::OPENSSL_EXT_SAN\)/#\1/i;s/,[^a-z]*ENV::OPENSSL_EXT_SAN[^,a-z]*//ig' "${TMP_CONF}"

  # LibreSSL does not use environment for ENV::** variables
  if [ "${OPENSSL_VARIANT}" == 'LibreSSL' ]; then
    for openssl_env in \
      OPENSSL_DN_COMMONNAME \
      OPENSSL_DN_EMAILADDRESS \
      OPENSSL_DN_ORGANIZATIONALUNIT \
      OPENSSL_DN_TITLE \
      OPENSSL_EXT_SAN \
    ; do
      [ -n "${!openssl_env}" ] && sed -i'' -e "s|\\\${ENV::${openssl_env}}|\"${!openssl_env}\"|ig" "${TMP_CONF}"
    done
  fi

  export OPENSSL_CONF="${TMP_CONF}"
}

# Files
function _file_date() {
  FILE_DATE="${1##*-}"
  echo "${FILE_DATE%.*}"
}

function _file_key() {
  [ -z "${OPT_ID}" ] && _ERROR "Missing/empty ID (+id ...)" && return 1
  if [ -n "${OPT_DATE}" ]; then
    FILE_KEY="${OPENSSL_DIR_KEYS}/${OPT_ID}-key-${OPT_DATE}.pem"
  else
    FILE_KEY="${OPENSSL_DIR_KEYS}/${OPT_ID}-key-${DFLT_DATE}.pem"
    if [ ! -e "${FILE_KEY}" ]; then
      FILE_KEY="$(find "${OPENSSL_DIR_KEYS}" -type f -regex ".*/${OPT_ID//./\\.}-key-[0-9][0-9]*\.pem" | sort -V | tail -n -1)"
      [ -n "${FILE_KEY}" ] && _NOTICE "Unmatched/unspecified private key date; picked latest available date ($(_file_date "${FILE_KEY}"))" >&2
    fi
  fi
  echo "${FILE_KEY}"
  return 0
}

function _file_pub() {
  [ -z "${OPT_ID}" ] && _ERROR "Missing/empty ID (+id ...)" && return 1
  if [ -n "${OPT_DATE}" ]; then
    FILE_PUB="${OPENSSL_DIR_PUBS}/${OPT_ID}-pub-${OPT_DATE}.pem"
  else
    FILE_PUB="${OPENSSL_DIR_PUBS}/${OPT_ID}-pub-${DFLT_DATE}.pem"
    if [ ! -e "${FILE_PUB}" ]; then
      FILE_PUB="$(find "${OPENSSL_DIR_PUBS}" -type f -regex ".*/${OPT_ID//./\\.}-pub-[0-9][0-9]*\.pem" | sort -V | tail -n -1)"
      [ -n "${FILE_PUB}" ] && _NOTICE "Unmatched/unspecified public key date; picked latest available date ($(_file_date "${FILE_PUB}"))" >&2
    fi
  fi
  echo "${FILE_PUB}"
  return 0
}

function _file_attn() {
  [ -z "${OPT_ID}" ] && _ERROR "Missing/empty ID (+id ...)" && return 1
  if [ -n "${OPT_DATE}" ]; then
    FILE_ATTN="${OPENSSL_DIR_ATTNS}/${OPT_ID}-attn-${OPT_DATE}.pem"
  else
    FILE_ATTN="${OPENSSL_DIR_ATTNS}/${OPT_ID}-attn-${DFLT_DATE}.pem"
    if [ ! -e "${FILE_ATTN}" ]; then
      FILE_ATTN="$(find "${OPENSSL_DIR_ATTNS}" -type l -regex ".*/${OPT_ID//./\\.}-attn-[0-9][0-9]*\.pem" | sort -V | tail -n -1)"
      [ -n "${FILE_ATTN}" ] && _NOTICE "Unmatched/unspecified attestation date; picked latest available date ($(_file_date "${FILE_ATTN}"))" >&2
    fi
  fi
  echo "${FILE_ATTN}"
  return 0
}

function _file_req() {
  [ -z "${OPT_ID}" ] && _ERROR "Missing/empty ID (+id ...)" && return 1
  if [ -n "${OPT_DATE}" ]; then
    FILE_REQ="${OPENSSL_DIR_REQS}/${OPT_ID}-req-${OPT_DATE}.pem"
  else
    FILE_REQ="${OPENSSL_DIR_REQS}/${OPT_ID}-req-${DFLT_DATE}.pem"
    if [ ! -e "${FILE_REQ}" ]; then
      FILE_REQ="$(find "${OPENSSL_DIR_REQS}" -type f -regex ".*/${OPT_ID//./\\.}-req-[0-9][0-9]*\.pem" | sort -V | tail -n -1)"
      [ -n "${FILE_REQ}" ] && _NOTICE "Unmatched/unspecified CSR date; picked latest available date ($(_file_date "${FILE_REQ}"))" >&2
    fi
  fi
  echo "${FILE_REQ}"
  return 0
}

function _file_cert() {
  [ -z "${OPT_ID}" ] && _ERROR "Missing/empty ID (+id ...)" && return 1
  if [ -n "${OPT_DATE}" ]; then
    FILE_CERT="${OPENSSL_DIR_CERTS}/${OPT_ID}-cert-${OPT_DATE}.pem"
  else
    FILE_CERT="${OPENSSL_DIR_CERTS}/${OPT_ID}-cert-${DFLT_DATE}.pem"
    if [ ! -e "${FILE_CERT}" ]; then
      FILE_CERT="$(find "${OPENSSL_DIR_CERTS}" -type l -regex ".*/${OPT_ID//./\\.}-cert-[0-9][0-9]*\.pem" | sort -V | tail -n -1)"
      [ -n "${FILE_CERT}" ] && _NOTICE "Unmatched/unspecified certificate date; picked latest available date ($(_file_date "${FILE_CERT}"))" >&2
    fi
  fi
  echo "${FILE_CERT}"
  return 0
}

function _file_crl() {
  if [ -n "${OPT_DATE}" ]; then
    FILE_CRL="${OPENSSL_DIR_CRLS}/crl-${OPT_DATE}.pem"
  else
    FILE_CRL="${OPENSSL_DIR_CRLS}/crl-${DFLT_DATE}.pem"
    if [ ! -e "${FILE_CRL}" ]; then
      FILE_CRL="$(find "${OPENSSL_DIR_CRLS}" -type f -regex ".*/crl-[0-9][0-9]*\.pem" | sort -V | tail -n -1)"
      [ -n "${FILE_CRL}" ] && _NOTICE "Unmatched/unspecified CRL date; picked latest available date ($(_file_date "${FILE_CRL}"))" >&2
    fi
  fi
  echo "${FILE_CRL}"
  return 0
}


## Commands
case "${ARG_COMMAND}" in

  ########################################################################
  # Certification Authority (CA)
  #

  'help-ca') cat << EOF
USAGE: ${SCRIPT} <command> [options]

SYNOPSIS:
  Certification Authority (CA) management

COMMANDS:

  ${SCRIPT} make-ca [<options>]
    Create the certificate authority (CA) self-signed certificate
    (and initialize other required resources)

  ${SCRIPT} show-ca
    Show the CA certificate

  ${SCRIPT} man-ca
    Show OpenSSL ad-hoc manual page

OPTIONS:

  +name <common-name>
    CA certificate distinguished name (DN) common name (CN)

(special usage)

  +id CA:EXTERNAL
    Initialize this CA as an external CA
    The CA private key is not available
    Signed certificates can only imported (not issued)

  +id CA:INTERMEDIATE
    Initialize this CA as an intermediate, issuing CA
    The CA private key (key.pem) and certificate (cert.pem) must already be
    present in the CA sub-folder (${OPENSSL_DIR_CA})
EOF
    ;;


  'man-ca')
    man openssl-ca || echo 'https://www.openssl.org/docs/man1.1.1/man1/ca.html'
    ;;


  'make-ca')
    # Resources
    [ ! -e "${OPENSSL_DIR_CA}" ] && mkdir "${OPENSSL_DIR_CA}"
    { [ ! -d "${OPENSSL_DIR_CA}" ] || [ ! -w "${OPENSSL_DIR_CA}" ]; } && _ERROR "Invalid/unwritable CA directory (${OPENSSL_DIR_CA})"  && exit 1
    [ ! -e "${OPENSSL_DIR_CA_CERTS}" ] && mkdir "${OPENSSL_DIR_CA_CERTS}"
    { [ ! -d "${OPENSSL_DIR_CA_CERTS}" ] || [ ! -w "${OPENSSL_DIR_CA_CERTS}" ]; } && _ERROR "Invalid/unwritable CA-signed certificates directory (${OPENSSL_DIR_CA_CERTS})"  && exit 1
    [ ! -e "${OPENSSL_FILE_CA_DATABASE}" ] && touch "${OPENSSL_FILE_CA_DATABASE}"
    { [ ! -f "${OPENSSL_FILE_CA_DATABASE}" ] || [ ! -w "${OPENSSL_FILE_CA_DATABASE}" ]; } && _ERROR "Invalid/unwritable CA database file (${OPENSSL_FILE_CA_DATABASE})"  && exit 1

    # External CA ?
    [ "${OPT_ID}" == 'CA:EXTERNAL' ] && exit 0

    # Resources (cont'd)
    [ ! -e "${OPENSSL_FILE_CA_DATABASE}.attr" ] && touch "${OPENSSL_FILE_CA_DATABASE}.attr"
    { [ ! -f "${OPENSSL_FILE_CA_DATABASE}.attr" ] || [ ! -w "${OPENSSL_FILE_CA_DATABASE}.attr" ]; } && _ERROR "Invalid/unwritable CA attr file (${OPENSSL_FILE_CA_DATABASE}.attr)"  && exit 1
    [ ! -e "${OPENSSL_FILE_CA_SERIAL}" ] && echo '01' > "${OPENSSL_FILE_CA_SERIAL}"
    { [ ! -f "${OPENSSL_FILE_CA_SERIAL}" ] || [ ! -w "${OPENSSL_FILE_CA_SERIAL}" ]; } && _ERROR "Invalid/unwritable CA serial file (${OPENSSL_FILE_CA_SERIAL})"  && exit 1
    [ ! -e "${OPENSSL_FILE_CA_CRLNUMBER}" ] && echo '01' > "${OPENSSL_FILE_CA_CRLNUMBER}"
    { [ ! -f "${OPENSSL_FILE_CA_CRLNUMBER}" ] || [ ! -w "${OPENSSL_FILE_CA_CRLNUMBER}" ]; } && _ERROR "Invalid/unwritable CA CRL number file (${OPENSSL_FILE_CA_CRLNUMBER})"  && exit 1

    # Intermediate CA ?
    [ "${OPT_ID}" == 'CA:INTERMEDIATE' ] && exit 0

    # Private key
    [ -n "${OPT_PKCS11_URI}" ] && _ERROR "Certificate authority cannot be created via PKCS#11" && exit 1
    FILE_KEY="${OPENSSL_FILE_CA_KEY}"
    if [ ! -e "${FILE_KEY}" ]; then
      [ -z "${OPENSSL_PASSWORD}" ] && read -r -s -p "CA (private key) password: " OPENSSL_PASSWORD && export OPENSSL_PASSWORD && echo
      OPENSSL_OUTPUT="${FILE_KEY}" "${0}" make-key +id 'CA:INTERNAL' || exit $?
    fi

    # Certificate (self-signed)
    FILE_CERT="${OPENSSL_FILE_CA_CERT}"
    [ -e "${FILE_CERT}" ] && _ERROR "CA certificate already exists (${FILE_CERT})" && exit 1
    [ -z "${OPENSSL_DN_COMMONNAME}" ] && export OPENSSL_DN_COMMONNAME='Authority'
    # shellcheck disable=2086
    OPENSSL_INPUT="${FILE_KEY}" OPENSSL_OUTPUT="${FILE_CERT}" "${0}" make-cert +id 'CA:INTERNAL' -selfsign -extensions 'CA_Authority_Extensions' ${OPT_OPENSSL} || exit $?
    ;;


  'show-ca')
    # Input
    if [ -n "${OPENSSL_INPUT}" ]; then
      FILE_CERT="${OPENSSL_INPUT}"
    else
      FILE_CERT="${OPENSSL_DIR_CA}/cert.pem"
    fi
    { [ ! -f "${FILE_CERT}" ] || [ ! -r "${FILE_CERT}" ]; } && _ERROR "Invalid/unreadable certificate (${FILE_CERT:-<no match>})" && exit 1
    grep -q -F 'CERTIFICATE' "${FILE_CERT}" && FORMAT_CERT='PEM' || FORMAT_CERT='DER'

    # OpenSSL
    # shellcheck disable=2086
    OPENSSL_CONF='/dev/null' openssl x509 -inform "${FORMAT_CERT}" -in "${FILE_CERT}" ${OPT_OPENSSL}
    ;;



  ########################################################################
  # Private keys
  #

  'help-key') cat << EOF
USAGE: ${SCRIPT} <command> [options]

SYNOPSIS:
  Private keys management

COMMANDS:

  ${SCRIPT} make-key [<options>]
    Create a private key

  ${SCRIPT} import-key [<options>] [-inform {PEM|DER}] [-in ...]
    Import an existing private key (from stdin or specified file)

  ${SCRIPT} show-key [<options>]
    Show a private key

  ${SCRIPT} man-key
    Show OpenSSL ad-hoc manual page

OPTIONS:

  +id <ID>
    Private key identifier

(make-key)

  +algorithm {rsa|dsa|ec}
    Public cryptography algorithm (default: ${DFLT_ALGO_PKI})

  +length <bits>
    Key length, for RSA and DSA keys (default: ${DFLT_KEY_LENGTH})

  +curve <curve-name>
    Key curve, for EC keys (default: ${DFLT_KEY_CURVE})
EOF
    ;;


  'man-key')
    man openssl-genpkey || echo 'https://www.openssl.org/docs/man1.1.1/man1/genpkey.html'
    ;;


  'make-key')
    [ -n "${OPT_PKCS11_URI}" ] && _ERROR "Private key cannot be created via PKCS#11 (use 'pkcs11-tool')" && exit 1

    # Output
    if [ -n "${OPENSSL_OUTPUT}" ]; then
      FILE_KEY="${OPENSSL_OUTPUT}"
    else
      [ -z "${OPT_ID}" ] && _ERROR "Missing/empty ID (+id ...)" && exit 1
      FILE_KEY="${OPENSSL_DIR_KEYS}/${OPT_ID}-key-${DFLT_DATE}.pem"
    fi
    [ -e "${FILE_KEY}" ] && _ERROR "Private key already exists (${FILE_KEY})" && exit 1

    # OpenSSL
    [ -z "${OPENSSL_PASSWORD}" ] && read -r -s -p "Private key password: " OPENSSL_PASSWORD && export OPENSSL_PASSWORD && echo
    case "${OPT_ALGO_PKI}" in
      'rsa')
        openssl genpkey -algorithm RSA -pkeyopt "rsa_keygen_bits:${OPT_KEY_LENGTH}" -out "${FILE_KEY}" -pass env:OPENSSL_PASSWORD -${OPENSSL_ALGO_WRAP} || exit 1
        ;;
      'dsa')
        TMP_PARAM="$(mktemp)"
        # shellcheck disable=2064
        trap "rm -f '${TMP_PARAM}'" EXIT
        openssl genpkey -genparam -algorithm DSA -pkeyopt "dsa_paramgen_bits:${OPT_KEY_LENGTH}" -out "${TMP_PARAM}" || exit 1
        openssl genpkey -paramfile "${TMP_PARAM}" -out "${FILE_KEY}" -pass env:OPENSSL_PASSWORD -${OPENSSL_ALGO_WRAP} || exit 1
        ;;
      'ec')
        TMP_PARAM="$(mktemp)"
        # shellcheck disable=2064
        trap "rm -f '${TMP_PARAM}'" EXIT
        openssl genpkey -genparam -algorithm EC -pkeyopt "ec_paramgen_curve:${OPT_KEY_CURVE}" -out "${TMP_PARAM}" || exit 1
        openssl genpkey -paramfile "${TMP_PARAM}" -out "${FILE_KEY}" -pass env:OPENSSL_PASSWORD -${OPENSSL_ALGO_WRAP} || exit 1
        ;;
      *)
        _ERROR "Unsupported algorithm (${OPT_ALGO_PKI})" && exit 1
        ;;
    esac
    _INFO "Private key successfully created (${FILE_KEY})"
    [ -n "${OPT_VERBOSE}" ] && openssl pkey -noout -text -in "${FILE_KEY}" -passin env:OPENSSL_PASSWORD
    ;;


  'import-key')
    [ -n "${OPT_PKCS11_URI}" ] && _ERROR "Private key cannot be imported from PKCS#11" && exit 1

    # Output
    if [ -n "${OPENSSL_OUTPUT}" ]; then
      FILE_KEY="${OPENSSL_OUTPUT}"
    else
      [ -z "${OPT_ID}" ] && _ERROR "Missing/empty ID (+id ...)" && exit 1
      FILE_KEY="${OPENSSL_DIR_KEYS}/${OPT_ID}-key-${DFLT_DATE}.pem"
    fi
    [ -e "${FILE_KEY}" ] && _ERROR "Private key already exists (${FILE_KEY})" && exit 1

    # OpenSSL
    [ -z "${OPENSSL_PASSWORD}" ] && read -r -s -p "Private key password: " OPENSSL_PASSWORD && export OPENSSL_PASSWORD && echo
    # shellcheck disable=2086
    openssl pkey -out "${FILE_KEY}" -passout env:OPENSSL_PASSWORD "-${OPENSSL_ALGO_WRAP}" ${OPT_OPENSSL} || exit 1
    [ ! -s "${FILE_KEY}" ] && rm -f "${FILE_KEY}" && _ERROR "Private key import failed" && exit 1
    _INFO "Private key successfully imported (${FILE_KEY})"
    [ -n "${OPT_VERBOSE}" ] && openssl pkey -noout -text -in "${FILE_KEY}" -passin env:OPENSSL_PASSWORD
    ;;


  'show-key')
    [ -n "${OPT_PKCS11_URI}" ] && _ERROR "Private key cannot be displayed from PKCS#11" && exit 1

    # Input
    if [ -n "${OPENSSL_INPUT}" ]; then
      FILE_KEY="${OPENSSL_INPUT}"
    else
      FILE_KEY="$(_file_key)" || exit $?
    fi
    { [ ! -f "${FILE_KEY}" ] || [ ! -r "${FILE_KEY}" ]; } && _ERROR "Invalid/unreadable private key (${FILE_KEY:-<no match>})" && exit 1
    grep -q -F 'PRIVATE KEY' "${FILE_KEY}" && FORMAT_KEY='PEM' || FORMAT_KEY='DER'

    # OpenSSL
    [ -z "${OPENSSL_PASSWORD}" ] && read -r -s -p "Private key password: " OPENSSL_PASSWORD && export OPENSSL_PASSWORD && echo
    # shellcheck disable=2086
    openssl pkey -inform "${FORMAT_KEY}" -in "${FILE_KEY}" -passin env:OPENSSL_PASSWORD ${OPT_OPENSSL}
    ;;



  ########################################################################
  # Public keys
  #

  'help-pub') cat << EOF
USAGE: ${SCRIPT} <command> [options]

SYNOPSIS:
  Public keys management

COMMANDS:

  ${SCRIPT} make-pub [<options>]
    Create a public key

  ${SCRIPT} import-pub [<options>] [-inform {PEM|DER}] [-in ...]
    Import an existing public key (from stdin or specified file)

  ${SCRIPT} show-pub [<options>]
    Show a public key

  ${SCRIPT} man-pub
    Show OpenSSL ad-hoc manual page

OPTIONS:

  +id <ID>
    Public key identifier
EOF
    ;;


  'man-pub')
    man openssl-pkey || echo 'https://www.openssl.org/docs/man1.1.1/man1/pkey.html'
    ;;


  'make-pub')
    # Output
    if [ -n "${OPENSSL_OUTPUT}" ]; then
      FILE_PUB="${OPENSSL_OUTPUT}"
    else
      [ -z "${OPT_ID}" ] && _ERROR "Missing/empty ID (+id ...)" && exit 1
      FILE_PUB="${OPENSSL_DIR_PUBS}/${OPT_ID}-pub-${DFLT_DATE}.pem"
    fi
    [ -e "${FILE_PUB}" ] && _ERROR "Public key already exists (${FILE_PUB})" && exit 1

    # OpenSSL
    if [ -z "${OPT_PKCS11_URI}" ]; then
      # Input
      if [ -n "${OPENSSL_INPUT}" ]; then
        FILE_KEY="${OPENSSL_INPUT}"
      else
        FILE_KEY="$(_file_key)" || exit $?
      fi
      if [ -z "${FILE_KEY}" ]; then
        FILE_KEY="${OPENSSL_DIR_KEYS}/${OPT_ID}-key-${DFLT_DATE}.pem"
      fi
      if [ ! -e "${FILE_KEY}" ] && [ -n "${OPT_AUTO}" ]; then
        OPENSSL_OUTPUT="${FILE_KEY}" "${0}" make-key "${OPTS[@]}" || exit $?
      fi
      { [ ! -f "${FILE_KEY}" ] || [ ! -r "${FILE_KEY}" ]; } && _ERROR "Invalid/unreadable private key (${FILE_KEY:-<no match>})" && exit 1
      grep -q -F 'PRIVATE KEY' "${FILE_KEY}" && FORMAT_KEY='PEM' || FORMAT_KEY='DER'

      # OpenSSL [cont'd]
      [ -z "${OPENSSL_PASSWORD}" ] && read -r -s -p "Private key password: " OPENSSL_PASSWORD && export OPENSSL_PASSWORD && echo
      openssl pkey -inform ${FORMAT_KEY} -in "${FILE_KEY}" -passin env:OPENSSL_PASSWORD -pubout -out "${FILE_PUB}" || exit 1
    else
      openssl pkey -engine pkcs11 -inform engine -in "${OPT_PKCS11_URI}" -pubout -out "${FILE_PUB}" || exit 1
    fi
    [ ! -s "${FILE_PUB}" ] && rm -f "${FILE_PUB}" && _ERROR "Public key creation failed" && exit 1
    _INFO "Public key successfully created (${FILE_PUB})"
    [ -n "${OPT_VERBOSE}" ] && openssl pkey -noout -text -pubin -in "${FILE_PUB}"
    ;;


  'import-pub')
    # Output
    if [ -n "${OPENSSL_OUTPUT}" ]; then
      FILE_PUB="${OPENSSL_OUTPUT}"
    else
      [ -z "${OPT_ID}" ] && _ERROR "Missing/empty ID (+id ...)" && exit 1
      FILE_PUB="${OPENSSL_DIR_PUBS}/${OPT_ID}-pub-${DFLT_DATE}.pem"
    fi
    [ -e "${FILE_PUB}" ] && _ERROR "Public key already exists (${FILE_PUB})" && exit 1

    # OpenSSL
    # shellcheck disable=2086
    openssl pkey -pubout -out "${FILE_PUB}" -pubin ${OPT_OPENSSL} || exit 1
    [ ! -s "${FILE_PUB}" ] && rm -f "${FILE_PUB}" && _ERROR "Public key import failed" && exit 1
    _INFO "Public key successfully imported (${FILE_PUB})"
    [ -n "${OPT_VERBOSE}" ] && openssl pkey -noout -text -pubin -in "${FILE_PUB}"
    ;;


  'show-pub')
    # Input
    if [ -n "${OPENSSL_INPUT}" ]; then
      FILE_PUB="${OPENSSL_INPUT}"
    else
      FILE_PUB="$(_file_pub)" || exit $?
    fi
    { [ ! -f "${FILE_PUB}" ] || [ ! -r "${FILE_PUB}" ]; } && _ERROR "Invalid/unreadable public key (${FILE_PUB:-<no match>})" && exit 1
    grep -q -F 'PUBLIC KEY' "${FILE_PUB}" && FORMAT_PUB='PEM' || FORMAT_PUB='DER'

    # OpenSSL
    # shellcheck disable=2086
    openssl pkey -pubin -inform "${FORMAT_PUB}" -in "${FILE_PUB}" ${OPT_OPENSSL}
    ;;



  ########################################################################
  # Attestations
  #

  'help-attn') cat << EOF
USAGE: ${SCRIPT} <command> [options]

SYNOPSIS:
  Attestations management

COMMANDS:

  ${SCRIPT} import-attn [<options>] [-inform {PEM|DER}] [-in ...]
    Import an existing attestation (from stdin or specified file)

  ${SCRIPT} show-attn [<options>]
    Show an attestation (certificate)

  ${SCRIPT} verify-attn [<options>]
    Verify the attestation is issued by an accepted Certification Authority
    (<-> ${OPENSSL_FILE_CA_ATTNS})

OPTIONS:

  +id <ID>
    Attestation identifier

(import-attn)

  +chain <file>
    Intermediate Certification Authority (ICA) to chain into the attestation
EOF
    ;;


  'import-attn')
    # Output
    if [ -n "${OPENSSL_OUTPUT}" ]; then
      FILE_ATTN="${OPENSSL_OUTPUT}"
    else
      [ -z "${OPT_ID}" ] && _ERROR "Missing/empty ID (+id ...)" && exit 1
      FILE_ATTN="${OPENSSL_DIR_ATTNS}/${OPT_ID}-attn-${DFLT_DATE}.pem"
    fi
    [ -e "${FILE_ATTN}" ] && _ERROR "Attestation already exists (${FILE_ATTN})" && exit 1

    # OpenSSL
    # NOTE: We allow the attestation file to include the ICA chain if applicable (for verification purposes)
    # shellcheck disable=2086
    OPENSSL_CONF='/dev/null' openssl x509 -out "${FILE_ATTN}" ${OPT_OPENSSL} || exit 1
    for ica in "${OPT_CHAIN[@]}"; do
      grep -q -F 'BEGIN CERTIFICATE' "${ica}" && format_ica='PEM' || format_ica='DER'
      # shellcheck disable=2086
      OPENSSL_CONF='/dev/null' openssl x509 --inform "${format_ica}" -in "${ica}" >> "${FILE_ATTN}" || exit 1
    done
    [ ! -s "${FILE_ATTN}" ] && rm -f "${FILE_ATTN}" && _ERROR "Attestation (certificate) import failed" && exit 1
    _INFO "Attestation successfully imported (${FILE_ATTN})"
    [ -n "${OPT_VERBOSE}" ] && OPENSSL_CONF=/dev/null openssl x509 -noout -text -in "${FILE_ATTN}"
    ;;


  'show-attn')
    # Input
    if [ -n "${OPENSSL_INPUT}" ]; then
      FILE_ATTN="${OPENSSL_INPUT}"
    else
      FILE_ATTN="$(_file_attn)" || exit $?
    fi
    { [ ! -f "${FILE_ATTN}" ] || [ ! -r "${FILE_ATTN}" ]; } && _ERROR "Invalid/unreadable attestation (${FILE_ATTN:-<no match>})" && exit 1
    grep -q -F 'BEGIN CERTIFICATE' "${FILE_ATTN}" && FORMAT_ATTN='PEM' || FORMAT_ATTN='DER'

    # OpenSSL
    # shellcheck disable=2086
    OPENSSL_CONF='/dev/null' openssl x509 -inform "${FORMAT_ATTN}" -in "${FILE_ATTN}" ${OPT_OPENSSL}
    ;;


  'verify-attn')
    { [ ! -f "${OPENSSL_FILE_CA_ATTNS}" ] || [ ! -r "${OPENSSL_FILE_CA_ATTNS}" ]; } && _ERROR "Invalid/unreadable attestation authorities (${OPENSSL_FILE_CA_ATTNS})" && exit 1

    # Input
    if [ -n "${OPENSSL_INPUT}" ]; then
      FILE_ATTN="${OPENSSL_INPUT}"
    else
      FILE_ATTN="$(_file_attn)" || exit $?
    fi
    { [ ! -f "${FILE_ATTN}" ] || [ ! -r "${FILE_ATTN}" ]; } && _ERROR "Invalid/unreadable attestation (${FILE_ATTN:-<no match>})" && exit 1
    grep -q -F 'BEGIN CERTIFICATE' "${FILE_ATTN}" && FORMAT_ATTN='PEM' || FORMAT_ATTN='DER'
    [ "${FORMAT_ATTN}" != 'PEM' ] && _ERROR "Attestation verification supports only PEM format (${FILE_ATTN})" && exit 1

    # OpenSSL
    # NOTE: We allow the attestation file to include the ICA chain if applicable (<-> -untrusted ...)
    # shellcheck disable=2086
    OPENSSL_CONF='/dev/null' openssl verify -CAfile "${OPENSSL_FILE_CA_ATTNS}" -untrusted "${FILE_ATTN}" ${OPT_OPENSSL} "${FILE_ATTN}"
    ;;



  ########################################################################
  # Certificate Signing Requests (CSR)
  #

  'help-req') cat << EOF
USAGE: ${SCRIPT} <command> [options]

SYNOPSIS:
  Certificate Signing Requests (CSR) management

COMMANDS:

  ${SCRIPT} make-req [<options>]
    Create a certificate signing request

  ${SCRIPT} import-req [<options>] [-inform {PEM|DER}] [-in ...]
    Import an existing certificate signing request (from stdin or specified file)

  ${SCRIPT} show-req [<options>]
    Show a certificate signing request

  ${SCRIPT} attest-req [<options>]
    Verify the certificate signing request matches the subscriber attestation

  ${SCRIPT} man-req
    Show OpenSSL ad-hoc manual page

OPTIONS:

  +id <ID>
    Certificate signing request identifier

(make-req)

  +name <common-name>
    Certificate distinguished name (DN) common name (CN)

  +email <email-address>
    Certificate distinguished name (DN) e-mail address (emailAddress)

  +title <title>
    Certificate distinguished name (DN) title (title)

  +unit <organizational-unit>
    Certificate distinguished name (DN) organizational unit (OU)

  +san-{dns,uri,ip,rid,dir,email,other} [+san-...]
    Requested certificate Subject Alternative Name (SAN) extensions
EOF
    ;;


  'man-req')
    man openssl-req || echo 'https://www.openssl.org/docs/man1.1.1/man1/req.html'
    ;;


  'make-req')
    # Output
    if [ -n "${OPENSSL_OUTPUT}" ]; then
      FILE_REQ="${OPENSSL_OUTPUT}"
    else
      [ -z "${OPT_ID}" ] && _ERROR "Missing/empty ID (+id ...)" && exit 1
      FILE_REQ="${OPENSSL_DIR_REQS}/${OPT_ID}-req-${DFLT_DATE}.pem"
    fi
    [ -e "${FILE_REQ}" ] && _ERROR "Certificate signing request already exists (${FILE_REQ})" && exit 1

    # Configuration
    [ -z "${OPENSSL_DN_COMMONNAME}" ] && _ERROR "Missing/empty name (+name ...)" && exit 1
    _openssl_conf_quirks

    # OpenSSL
    if [ -z "${OPT_PKCS11_URI}" ]; then
      # Input
      if [ -n "${OPENSSL_INPUT}" ]; then
        FILE_KEY="${OPENSSL_INPUT}"
      else
        FILE_KEY="$(_file_key)" || exit $?
      fi
      if [ -z "${FILE_KEY}" ]; then
        FILE_KEY="${OPENSSL_DIR_KEYS}/${OPT_ID}-key-${DFLT_DATE}.pem"
      fi
      if [ ! -e "${FILE_KEY}" ] && [ -n "${OPT_AUTO}" ]; then
        OPENSSL_OUTPUT="${FILE_KEY}" "${0}" make-key "${OPTS[@]}" || exit $?
      fi
      { [ ! -f "${FILE_KEY}" ] || [ ! -r "${FILE_KEY}" ]; } && _ERROR "Invalid/unreadable private key (${FILE_KEY:-<no match>})" && exit 1
      grep -q -F 'PRIVATE KEY' "${FILE_KEY}" && FORMAT_KEY='PEM' || FORMAT_KEY='DER'

      # OpenSSL [cont'd]
      [ -z "${OPENSSL_PASSWORD}" ] && read -r -s -p "Private key password: " OPENSSL_PASSWORD && export OPENSSL_PASSWORD && echo
      # shellcheck disable=2086
      openssl req -new -keyform "${FORMAT_KEY}" -key "${FILE_KEY}" -passin env:OPENSSL_PASSWORD -out "${FILE_REQ}" ${OPT_OPENSSL} || exit 1
    else
      # shellcheck disable=2086
      openssl req -new -engine pkcs11 -keyform engine -key "${OPT_PKCS11_URI}" -out "${FILE_REQ}" ${OPT_OPENSSL} || exit 1
    fi
    [ ! -s "${FILE_REQ}" ] && rm -f "${FILE_REQ}" && _ERROR "Certificate signing request creation failed" && exit 1
    _INFO "Certificate signing request successfully created (${FILE_REQ})"
    [ -n "${OPT_VERBOSE}" ] && openssl req -noout -text -in "${FILE_REQ}"
    ;;


  'import-req')
    # Output
    if [ -n "${OPENSSL_OUTPUT}" ]; then
      FILE_REQ="${OPENSSL_OUTPUT}"
    else
      [ -z "${OPT_ID}" ] && _ERROR "Missing/empty ID (+id ...)" && exit 1
      FILE_REQ="${OPENSSL_DIR_REQS}/${OPT_ID}-req-${DFLT_DATE}.pem"
    fi
    [ -e "${FILE_REQ}" ] && _ERROR "Certificate signing request already exists (${FILE_REQ})" && exit 1

    # OpenSSL
    # shellcheck disable=2086
    OPENSSL_CONF='/dev/null' openssl req -out "${FILE_REQ}" ${OPT_OPENSSL} || exit 1
    [ ! -s "${FILE_REQ}" ] && rm -f "${FILE_REQ}" && _ERROR "Certificate signing request import failed" && exit 1
    _INFO "Certificate signing request successfully imported (${FILE_REQ})"
    [ -n "${OPT_VERBOSE}" ] && OPENSSL_CONF=/dev/null openssl req -noout -text -in "${FILE_REQ}"
    ;;


  'show-req')
    # Input
    if [ -n "${OPENSSL_INPUT}" ]; then
      FILE_REQ="${OPENSSL_INPUT}"
    else
      FILE_REQ="$(_file_req)" || exit $?
    fi
    { [ ! -f "${FILE_REQ}" ] || [ ! -r "${FILE_REQ}" ]; } && _ERROR "Invalid/unreadable certificate signing request (${FILE_REQ:-<no match>})" && exit 1
    grep -q -F 'CERTIFICATE REQUEST' "${FILE_REQ}" && FORMAT_REQ='PEM' || FORMAT_REQ='DER'

    # OpenSSL
    # shellcheck disable=2086
    OPENSSL_CONF='/dev/null' openssl req -inform "${FORMAT_REQ}" -in "${FILE_REQ}" ${OPT_OPENSSL}
    ;;


  'attest-req')
    # Input
    if [ -n "${OPENSSL_INPUT}" ]; then
      FILE_REQ="${OPENSSL_INPUT}"
    else
      FILE_REQ="$(_file_req)" || exit $?
    fi
    { [ ! -f "${FILE_REQ}" ] || [ ! -r "${FILE_REQ}" ]; } && _ERROR "Invalid/unreadable certificate signing request (${FILE_REQ:-<no match>})" && exit 1
    grep -q -F 'CERTIFICATE REQUEST' "${FILE_REQ}" && FORMAT_REQ='PEM' || FORMAT_REQ='DER'

    # Attestation
    FILE_ATTN="$(_file_attn)" || exit $?
    { [ ! -f "${FILE_ATTN}" ] || [ ! -r "${FILE_ATTN}" ]; } && _ERROR "Invalid/unreadable attestation (${FILE_ATTN:-<no match>})" && exit 1

    # OpenSSL
    MODULUS_REQ="$(OPENSSL_CONF='/dev/null' openssl req -inform "${FORMAT_REQ}" -in "${FILE_REQ}" -noout -modulus)"
    MODULUS_ATTN="$(OPENSSL_CONF='/dev/null' openssl x509 -in "${FILE_ATTN}" -noout -modulus)"
    if [[ "${MODULUS_REQ}" == 'Modulus='* ]] && [ "${MODULUS_REQ}" == "${MODULUS_ATTN}" ]; then
      _INFO "Certificate signing request matches the attestation (${FILE_REQ##*/} <-> ${FILE_ATTN##*/})"
    else
      _ERROR "Certificate signing request does not match the attestation (${FILE_REQ##*/} <X> ${FILE_ATTN##*/})"
      exit 1
    fi
    ;;



  ########################################################################
  # Certificates
  #

  'help-cert') cat << EOF
USAGE: ${SCRIPT} <command> [options]

SYNOPSIS:
  Signed certificates management

COMMANDS:

  ${SCRIPT} make-cert [<options>] [-selfsign]
    Create a CA-signed (or self-signed) certificate

  ${SCRIPT} import-cert [<options>] [-inform {PEM|DER}] [-in ...]
    Import an existing certificate (from stdin or specified file)

  ${SCRIPT} show-cert [<options>]
    Show a certificate

  ${SCRIPT} attest-cert [<options>]
    Verify the certificate matches the subscriber attestation

  ${SCRIPT} list-certs [<options>]
    List CA-signed (only) certificates as TSV
    (ID DATE SUBJECT SERIAL STATUS DATE FILE)

  ${SCRIPT} revoke-cert [<options>] [-crl_reason ...]
    Revoke a CA-signed certificate

  ${SCRIPT} export-pkcs12 [<options>] [-out ...]
    Export the private key and certificate as a PKCS#12 bundle

  ${SCRIPT} verify-{crl,ocsp} [<options>]
    Verify a CA-signed certificate validity via CRL/OCSP

  ${SCRIPT} { man-cert | man-pkcs12 | man-verify | man-ocsp }
    Show OpenSSL ad-hoc manual page

OPTIONS:

  +id <ID>
    Certificate identifier

(make-cert)

  +san-{dns,uri,ip,rid,dir,email,other} [+san-...]
    Certificate Subject Alternative Name (SAN) extensions

(list-certs)

  +valid
    List valid certificates (the default)

  +expired
    List expired certificates

  +revoked
    List revoked certificates
EOF
    ;;


  'man-cert')
    man openssl-ca || echo 'https://www.openssl.org/docs/man1.1.1/man1/ca.html'
    ;;


  'make-cert')
    # Output
    if [ -n "${OPENSSL_OUTPUT}" ]; then
      FILE_CERT="${OPENSSL_OUTPUT}"
    else
      [ -z "${OPT_ID}" ] && _ERROR "Missing/empty ID (+id ...)" && exit 1
      FILE_CERT="${OPENSSL_DIR_CERTS}/${OPT_ID}-cert-${DFLT_DATE}.pem"
    fi
    [ -e "${FILE_CERT}" ] && _ERROR "Certificate already exists (${FILE_CERT})" && exit 1

    # OpenSSL
    if [[ "${OPT_OPENSSL}" == *'-selfsign'* ]]; then
      # ... self-sign
      OPT_OPENSSL="${OPT_OPENSSL//-selfsign/}"

      # Input
      if [ -z "${OPT_PKCS11_URI}" ]; then
        if [ -n "${OPENSSL_INPUT}" ]; then
          FILE_KEY="${OPENSSL_INPUT}"
        else
          FILE_KEY="$(_file_key)" || exit $?
        fi
        if [ -z "${FILE_KEY}" ]; then
          FILE_KEY="${OPENSSL_DIR_KEYS}/${OPT_ID}-key-${DFLT_DATE}.pem"
        fi
        if [ ! -e "${FILE_KEY}" ] && [ -n "${OPT_AUTO}" ]; then
          OPENSSL_OUTPUT="${FILE_KEY}" "${0}" make-key "${OPTS[@]}" || exit $?
        fi
        { [ ! -f "${FILE_KEY}" ] || [ ! -r "${FILE_KEY}" ]; } && _ERROR "Invalid/unreadable private key (${FILE_KEY:-<no match>})" && exit 1
        grep -q -F 'PRIVATE KEY' "${FILE_KEY}" && FORMAT_KEY='PEM' || FORMAT_KEY='DER'
      fi

      # Configuration
      [ -z "${OPENSSL_DN_COMMONNAME}" ] && _ERROR "Missing/empty name (+name ...)" && exit 1
      _openssl_conf_quirks

      # OpenSSL [cont'd]
      if [ -z "${OPT_PKCS11_URI}" ]; then
        [ -z "${OPENSSL_PASSWORD}" ] && read -r -s -p "Private key password: " OPENSSL_PASSWORD && export OPENSSL_PASSWORD && echo
        # shellcheck disable=2086
        openssl req -new -x509 -keyform "${FORMAT_KEY}" -key "${FILE_KEY}" -passin env:OPENSSL_PASSWORD -out "${FILE_CERT}" ${OPT_OPENSSL}
      else
        # shellcheck disable=2086
        openssl req -new -x509 -engine pkcs11 -keyform engine -key "${OPT_PKCS11_URI}" -out "${FILE_CERT}" ${OPT_OPENSSL}
      fi
      [ ! -s "${FILE_CERT}" ] && rm -f "${FILE_CERT}" && _ERROR "Certificate creation failed" && exit 1

      # Database (self-signed)
      serial="$(openssl x509 -noout -serial -in "${FILE_CERT}" | sed -e 's|^[^=]*=||')"
      subject="$(openssl x509 -noout -subject -in "${FILE_CERT}" | sed -e 's|[=,] *\([^ ]*\) *= *|/\1=|g;s|^[^/]*||')"
      date="$(date --utc --date "$(openssl x509 -noout -enddate -in "${FILE_CERT}" | sed -e 's|^[^=]*=||')" +'%y%m%d%H%M%SZ')"
      entry="V\t${date}\t\t${serial}\t${FILE_CERT##*/}\t${subject}"
      if ! echo -e "${entry}" >> "${OPENSSL_FILE_DATABASE}"; then
        _ERROR "Failed to add certificate to database (${OPENSSL_FILE_DATABASE})" && echo -e "${entry}" && exit 1
      fi

    else
      # ... CA-signed

      # Input
      if [ -n "${OPENSSL_INPUT}" ]; then
        FILE_REQ="${OPENSSL_INPUT}"
      else
        FILE_REQ="$(_file_req)" || exit $?
      fi
      if [ -z "${FILE_REQ}" ]; then
        FILE_REQ="${OPENSSL_DIR_REQS}/${OPT_ID}-req-${DFLT_DATE}.pem"
      fi
      if [ ! -e "${FILE_REQ}" ] && [ -n "${OPT_AUTO}" ]; then
        OPENSSL_OUTPUT="${FILE_REQ}" "${0}" make-req "${OPTS[@]}" || exit $?
      fi
      { [ ! -f "${FILE_REQ}" ] || [ ! -r "${FILE_REQ}" ]; } && _ERROR "Invalid/unreadable certificate signing request (${FILE_REQ:-<no match>})" && exit 1
      grep -q -F 'CERTIFICATE REQUEST' "${FILE_REQ}" || ( _ERROR "Certificate signing request MUST be in PEM format (${FILE_REQ})" && exit 1 )

      # Output [bis]
      CA_SERIAL="$(cat "${OPENSSL_FILE_CA_SERIAL}")"
      FILE_SERIAL="${OPENSSL_DIR_CA_CERTS}/${CA_SERIAL}.pem"
      [ -e "${FILE_SERIAL}" ] && echo "CRITICAL: A signed certificate already exists with the current serial (${FILE_SERIAL})" && exit 1

      # Configuration
      _openssl_conf_quirks

      # OpenSSL [cont'd]
      if [ -z "${OPT_PKCS11_URI}" ]; then
        [ -z "${OPENSSL_PASSWORD_CA}" ] && read -r -s -p "CA (private key) password: " OPENSSL_PASSWORD_CA && export OPENSSL_PASSWORD_CA && echo
        # shellcheck disable=2086
        openssl ca -passin env:OPENSSL_PASSWORD_CA -in "${FILE_REQ}" -out /dev/null -notext ${OPT_OPENSSL} || exit 1
      else
        # shellcheck disable=2086
        openssl ca -engine pkcs11 -keyform engine -keyfile "${OPT_PKCS11_URI}" -in "${FILE_REQ}" -out /dev/null -notext ${OPT_OPENSSL} || exit 1
      fi
      [ ! -s "${FILE_SERIAL}" ] && rm -f "${FILE_SERIAL}" && _ERROR "Certificate creation failed" && exit 1
      ln -s -r "${FILE_SERIAL}" "${FILE_CERT}"

      # Database (quirk)
      if ! sed -i'' -e "s|\t${CA_SERIAL}\tunknown|\t${CA_SERIAL}\t${FILE_CERT##*/}|" "${OPENSSL_FILE_CA_DATABASE}"; then
        _ERROR "Failed to update the certificates database (${OPENSSL_FILE_CA_DATABASE})" && exit 1
      fi

    fi
    _INFO "Certificate successfully signed (${FILE_CERT})"
    [ -n "${OPT_VERBOSE}" ] && openssl x509 -noout -text -in "${FILE_CERT}"
    ;;


  'import-cert')

    # Output
    if [ -n "${OPENSSL_OUTPUT}" ]; then
      FILE_CERT="${OPENSSL_OUTPUT}"
    else
      [ -z "${OPT_ID}" ] && _ERROR "Missing/empty ID (+id ...)" && exit 1
      FILE_CERT="${OPENSSL_DIR_CERTS}/${OPT_ID}-cert-${DFLT_DATE}.pem"
    fi
    [ -e "${FILE_CERT}" ] && _ERROR "Certificate already exists (${FILE_CERT})" && exit 1

    # OpenSSL
    # shellcheck disable=2086
    OPENSSL_CONF='/dev/null' openssl x509 -out "${FILE_CERT}" ${OPT_OPENSSL} || exit 1
    [ ! -s "${FILE_CERT}" ] && rm -f "${FILE_CERT}" && _ERROR "Certificate import failed" && exit 1
    _INFO "Certificate successfully imported (${FILE_CERT})"
    [ -n "${OPT_VERBOSE}" ] && OPENSSL_CONF=/dev/null openssl x509 -noout -text -in "${FILE_CERT}"

    # Database
    serial="$(openssl x509 -noout -serial -in "${FILE_CERT}" | sed -e 's|^[^=]*=||')"
    subject="$(openssl x509 -noout -subject -in "${FILE_CERT}" | sed -e 's|[=,] *\([^ ]*\) *= *|/\1=|g;s|^[^/]*||')"
    date="$(date --utc --date "$(openssl x509 -noout -enddate -in "${FILE_CERT}" | sed -e 's|^[^=]*=||')" +'%y%m%d%H%M%SZ')"
    entry="V\t${date}\t\t${serial}\t${FILE_CERT##*/}\t${subject}"
    [[ "${OPT_OPENSSL}" == *'-selfsign'* ]] && FILE_DATABASE="${OPENSSL_FILE_DATABASE}" || FILE_DATABASE="${OPENSSL_FILE_CA_DATABASE}"
    if ! echo -e "${entry}" >> "${FILE_DATABASE}"; then
      _ERROR "Failed to add certificate to database (${FILE_DATABASE})" && echo -e "${entry}" && exit 1
    fi

    # Relocate CA-signed certificate per its serial
    if [[ "${OPT_OPENSSL}" != *'-selfsign'* ]]; then
      FILE_SERIAL="${OPENSSL_DIR_CA_CERTS}/${serial}.pem"
      if ! mv "${FILE_CERT}" "${FILE_SERIAL}"; then
        _ERROR "Failed to relocate serialized certificate (${FILE_SERIAL})" && exit 1
      fi
      ln -s -r "${FILE_SERIAL}" "${FILE_CERT}"
    fi
    ;;


  'show-cert')
    # Input
    if [ -n "${OPENSSL_INPUT}" ]; then
      FILE_CERT="${OPENSSL_INPUT}"
    else
      FILE_CERT="$(_file_cert)" || exit $?
    fi
    { [ ! -f "${FILE_CERT}" ] || [ ! -r "${FILE_CERT}" ]; } && _ERROR "Invalid/unreadable certificate (${FILE_CERT:-<no match>})" && exit 1
    grep -q -F 'CERTIFICATE' "${FILE_CERT}" && FORMAT_CERT='PEM' || FORMAT_CERT='DER'

    # OpenSSL
    # shellcheck disable=2086
    OPENSSL_CONF='/dev/null' openssl x509 -inform "${FORMAT_CERT}" -in "${FILE_CERT}" ${OPT_OPENSSL}
    ;;


  'attest-cert')
    # Input
    if [ -n "${OPENSSL_INPUT}" ]; then
      FILE_CERT="${OPENSSL_INPUT}"
    else
      FILE_CERT="$(_file_cert)" || exit $?
    fi
    { [ ! -f "${FILE_CERT}" ] || [ ! -r "${FILE_CERT}" ]; } && _ERROR "Invalid/unreadable certificate (${FILE_CERT:-<no match>})" && exit 1
    grep -q -F 'BEGIN CERTIFICATE' "${FILE_CERT}" && FORMAT_CERT='PEM' || FORMAT_CERT='DER'

    # Attestation
    FILE_ATTN="$(_file_attn)" || exit $?
    { [ ! -f "${FILE_ATTN}" ] || [ ! -r "${FILE_ATTN}" ]; } && _ERROR "Invalid/unreadable attestation (${FILE_ATTN:-<no match>})" && exit 1

    # OpenSSL
    MODULUS_CERT="$(OPENSSL_CONF='/dev/null' openssl x509 -inform "${FORMAT_CERT}" -in "${FILE_CERT}" -noout -modulus)"
    MODULUS_ATTN="$(OPENSSL_CONF='/dev/null' openssl x509 -in "${FILE_ATTN}" -noout -modulus)"
    if [[ "${MODULUS_CERT}" == 'Modulus='* ]] && [ "${MODULUS_CERT}" == "${MODULUS_ATTN}" ]; then
      _INFO "Certificate matches the attestation (${FILE_CERT##*/} <-> ${FILE_ATTN##*/})"
    else
      _ERROR "Certificate does not match the attestation (${FILE_CERT##*/} <X> ${FILE_ATTN##*/})"
      exit 1
    fi
    ;;


  'revoke-cert')
    # Input
    if [ -n "${OPENSSL_INPUT}" ]; then
      FILE_CERT="${OPENSSL_INPUT}"
    else
      FILE_CERT="$(_file_cert)" || exit $?
    fi
    { [ ! -f "${FILE_CERT}" ] || [ ! -r "${FILE_CERT}" ]; } && _ERROR "Invalid/unreadable certificate (${FILE_CERT:-<no match>})" && exit 1
    grep -q -F 'CERTIFICATE' "${FILE_CERT}" || ( _ERROR "Certificate MUST be in PEM format (${FILE_CERT})" && exit 1 )

    # OpenSSL
    if [ -z "${OPT_PKCS11_URI}" ]; then
      [ -z "${OPENSSL_PASSWORD_CA}" ] && read -r -s -p "CA (private key) password: " OPENSSL_PASSWORD_CA && export OPENSSL_PASSWORD_CA && echo
      # shellcheck disable=2086
      openssl ca -passin env:OPENSSL_PASSWORD_CA -revoke "${FILE_CERT}" ${OPT_OPENSSL} || exit 1
    else
      # shellcheck disable=2086
      openssl ca -engine pkcs11 -keyform engine -keyfile "${OPT_PKCS11_URI}" -revoke "${FILE_CERT}" ${OPT_OPENSSL} || exit 1
    fi
    ;;


  'list-certs')
    # Input
    { [ ! -f "${OPENSSL_FILE_CA_DATABASE}" ] || [ ! -r "${OPENSSL_FILE_CA_DATABASE}" ]; } && _ERROR "Invalid/unreadable certificates database (${OPENSSL_FILE_CA_DATABASE})" && exit 1

    # Output
    [[ "${OPT_OPENSSL}" == *'-selfsign'* ]] && FILE_DATABASE="${OPENSSL_FILE_DATABASE}" || FILE_DATABASE="${OPENSSL_FILE_CA_DATABASE}"
    [ -z "${OPT_DATE}" ] && OPT_DATE="${DFLT_DATE}"
    [ -z "${OPT_LIST_VALID}" ] && [ -z "${OPT_LIST_EXPIRED}" ] && [ -z "${OPT_LIST_REVOKED}" ] && OPT_LIST_VALID='yes'
    [ -n "${OPT_LIST_VALID}" ] && awk -F$'\t' "{if(\$1==\"V\" &&${OPT_ID:+ \$5~\"^${OPT_ID}-cert\" &&} \"20\"\$2>\"${OPT_DATE}235959Z\"){split(\$5, FILE, \"-cert-\"); sub(/.pem$/, \"\", FILE[2]); printf(\"%s\\t%s\\t%s\\t%s\\tVALID\\t20%s\\t%s\\n\",FILE[1],FILE[2],\$6,\$4,\$2,\$5)}}" "${FILE_DATABASE}" | sort -k2 -k1
    [ -n "${OPT_LIST_EXPIRED}" ] && awk -F$'\t' "{if((\$1==\"V\"||\$1==\"E\") &&${OPT_ID:+ \$5~\"^${OPT_ID}-cert\" &&} \"20\"\$2<=\"${OPT_DATE}235959Z\"){split(\$5, FILE, \"-cert-\"); sub(/.pem$/, \"\", FILE[2]); printf(\"%s\\t%s\\t%s\\t%s\\tEXPIRED\\t20%s\\t%s\\n\",FILE[1],FILE[2],\$6,\$4,\$2,\$5)}}" "${FILE_DATABASE}" | sort -k6 -k1
    [ -n "${OPT_LIST_REVOKED}" ] && awk -F$'\t' "{if(\$1==\"R\" &&${OPT_ID:+ \$5~\"^${OPT_ID}-cert\" &&} \"20\"\$2>\"${OPT_DATE}235959Z\" && \"20\"\$3<=\"${OPT_DATE}235959Z\"){split(\$5, FILE, \"-cert-\"); sub(/.pem$/, \"\", FILE[2]); printf(\"%s\\t%s\\t%s\\t%s\\tREVOKED\\t20%s\\t%s\\n\",FILE[1],FILE[2],\$6,\$4,\$3,\$5)}}" "${FILE_DATABASE}" | sort -k6 -k1
    ;;



  ########################################################################
  # PKCS#12 (private key + certificate) bundle
  #

  'man-pkcs12')
    man openssl-pkcs12 || echo 'https://www.openssl.org/docs/man1.1.1/man1/pkcs12.html'
    ;;


  'export-pkcs12')
    # Input
    FILE_KEY="$(_file_key)" || exit $?
    { [ ! -f "${FILE_KEY}" ] || [ ! -r "${FILE_KEY}" ]; } && _ERROR "Invalid/unreadable private key (${FILE_KEY:-<no match>})" && exit 1
    grep -q -F 'PRIVATE KEY' "${FILE_KEY}" || ( _ERROR "Private key MUST be in PEM format (${FILE_KEY})" && exit 1 )
    FILE_CERT="$(_file_cert)" || exit $?
    { [ ! -f "${FILE_CERT}" ] || [ ! -r "${FILE_CERT}" ]; } && _ERROR "Invalid/unreadable certificate (${FILE_CERT:-<no match>})" && exit 1
    grep -q -F 'CERTIFICATE' "${FILE_CERT}" || ( _ERROR "Certificate MUST be in PEM format (${FILE_CERT})" && exit 1 )

    # OpenSSL
    [ -z "${OPENSSL_PASSWORD}" ] && read -r -s -p "Private key password: " OPENSSL_PASSWORD && export OPENSSL_PASSWORD && echo
    # shellcheck disable=2086
    OPENSSL_CONF='/dev/null' openssl pkcs12 -export -name "${OPT_ID}" -inkey "${FILE_KEY}" -passin env:OPENSSL_PASSWORD -in "${FILE_CERT}" ${OPT_OPENSSL}
    ;;



  ########################################################################
  # Certificate Revocation List (CRL)
  #

  'help-crl') cat << EOF
USAGE: ${SCRIPT} <command> [options]

SYNOPSIS:
  Certificate Revocation List (CRL) management

COMMANDS:

  ${SCRIPT} make-crl [<options>]
    Create the CA-signed certificate revocation list
    WARNING: The CRL number is increased each time a new CRL is created!

  ${SCRIPT} show-crl
    Show the certificate revocation list
EOF
    ;;


  'man-crl')
    man openssl-crl || echo 'https://www.openssl.org/docs/man1.1.1/man1/crl.html'
    ;;


  'make-crl')
    # Output
    if [ -n "${OPENSSL_OUTPUT}" ]; then
      FILE_CRL="${OPENSSL_OUTPUT}"
    else
      FILE_CRL="${OPENSSL_DIR_CRLS}/crl-${DFLT_DATE}.pem"
    fi
    [ -e "${FILE_CRL}" ] && _ERROR "Certificate revocation list already exists (${FILE_CRL})" && exit 1

    # OpenSSL
    if [ -z "${OPT_PKCS11_URI}" ]; then
      [ -z "${OPENSSL_PASSWORD_CA}" ] && read -r -s -p "CA (private key) password: " OPENSSL_PASSWORD_CA && export OPENSSL_PASSWORD_CA && echo
      # shellcheck disable=2086
      openssl ca -gencrl -passin env:OPENSSL_PASSWORD_CA -out "${FILE_CRL}" -updatedb ${OPT_OPENSSL}
    else
      # shellcheck disable=2086
      openssl ca -gencrl -engine pkcs11 -keyform engine -keyfile "${OPT_PKCS11_URI}" -out "${FILE_CRL}" -updatedb ${OPT_OPENSSL}
    fi
    _INFO "Certificate revocation list successfully created (${FILE_CRL})"
    [ -n "${OPT_VERBOSE}" ] && openssl crl -noout -text -in "${FILE_CRL}"
    ;;


  'show-crl')
    # Input
    if [ -n "${OPENSSL_INPUT}" ]; then
      FILE_CRL="${OPENSSL_INPUT}"
    else
      FILE_CRL="$(_file_crl)" || exit $?
    fi
    { [ ! -f "${FILE_CRL}" ] || [ ! -r "${FILE_CRL}" ]; } && _ERROR "Invalid/unreadable certificate revocation list (${FILE_CRL:-<no match>})" && exit 1
    grep -q -F 'X509 CRL' "${FILE_CRL}" && FORMAT_CRL='PEM' || FORMAT_CRL='DER'

    # OpenSSL
    # shellcheck disable=2086
    openssl crl -inform "${FORMAT_CRL}" -in "${FILE_CRL}" ${OPT_OPENSSL}
    ;;


  'man-verify')
    man openssl-verify || echo 'https://www.openssl.org/docs/man1.1.1/man1/verify.html'
    ;;


  'verify-crl')
    # Input
    if [ -n "${OPENSSL_INPUT}" ]; then
      FILE_CERT="${OPENSSL_INPUT}"
    else
      FILE_CERT="$(_file_cert)" || exit $?
    fi
    { [ ! -f "${FILE_CERT}" ] || [ ! -r "${FILE_CERT}" ]; } && _ERROR "Invalid/unreadable certificate (${FILE_CERT:-<no match>})" && exit 1
    grep -q -F 'CERTIFICATE' "${FILE_CERT}" || ( _ERROR "Certificate MUST be in PEM format (${FILE_CERT})" && exit 1 )

    # OpenSSL
    # shellcheck disable=2086
    OPENSSL_CONF='/dev/null' openssl verify -crl_check -crl_download -CAfile "${OPENSSL_FILE_CA_CERT}" ${OPT_OPENSSL} "${FILE_CERT}"
    ;;



  ########################################################################
  # OCSP
  #

  'man-ocsp')
    man openssl-ocsp || echo 'https://www.openssl.org/docs/man1.1.1/man1/ocsp.html'
    ;;


  'verify-ocsp')
    # Input
    if [ -n "${OPENSSL_INPUT}" ]; then
      FILE_CERT="${OPENSSL_INPUT}"
    else
      FILE_CERT="$(_file_cert)" || exit $?
    fi
    { [ ! -f "${FILE_CERT}" ] || [ ! -r "${FILE_CERT}" ]; } && _ERROR "Invalid/unreadable certificate (${FILE_CERT:-<no match>})" && exit 1
    grep -q -F 'CERTIFICATE' "${FILE_CERT}" || ( _ERROR "Certificate MUST be in PEM format (${FILE_CERT})" && exit 1 )

    # OpenSSL
    URI_OCSP="$(openssl x509 -noout -ocsp_uri -in "${FILE_CERT}" | head -n 1)"
    [ -z "${URI_OCSP}" ] && _ERROR "Certificate contains not OCSP Responder URI(s)" && exit 1
    # shellcheck disable=2086
    OPENSSL_CONF=/dev/null openssl ocsp -url "${URI_OCSP}" -issuer "${OPENSSL_FILE_CA_CERT}" -cert "${FILE_CERT}" ${OPT_OPENSSL}
    ;;



  ########################################################################
  # PKCS#11 integration (private key)
  #

  # NOTE: Those are only read-only primitives. Writing to PKCS#11 tokens
  #       is much better and safer done by using the token ad-hoc
  #       utilities; e.g. pkcs15-tool, yubico-piv-tool, etc.

  'help-pkcs11') cat << EOF
USAGE: ${SCRIPT} <command> [options]

SYNOPSIS:
  PKCS#11 integration (private key)

COMMANDS:

  ${SCRIPT} pkcs11-key [<options>]
    Retrieve a private key from a PKCS#11 token
    WARNING: Most PKCS#11 tokens will not let you retrieve a private key (by design)!

  ${SCRIPT} pkcs11-pub [<options>]
    Retrieve a public key from a PKCS#11 token

  ${SCRIPT} pkcs11-cert [<options>]
    Retrieve a certificate from a PKCS#11 token

  ${SCRIPT} pkcs11-test
    Test a PKCS#11 token

  ${SCRIPT} pkcs11-uri [<options>]
    Display a PKCS#11 token/object URI (RFC 7512)

  ${SCRIPT} man-pkcs11
    Show PKCS#11 ad-hoc manual page

OPTIONS:

  +pkcs11-token <label>
    PKCS#11 token label (as per 'pkcs11-tool --list-token-slots')

  +pkcs11-object <label>
    PKCS#11 object label (as per 'pkcs11-tool --list-objects')

  +pkcs11-id <id>
    PKCS#11 object ID (as per 'pkcs11-tool --list-objects')
EOF
    ;;


  'man-pkcs11')
    man pkcs11-tool
    ;;


  'pkcs11-key')
    # shellcheck disable=2086
    pkcs11-tool \
      ${OPT_PKCS11_TOKEN:+--token-label "${OPT_PKCS11_TOKEN}"} \
      ${OPT_PKCS11_OBJECT:+--label "${OPT_PKCS11_OBJECT}"} \
      ${OPT_PKCS11_ID:+--id "${OPT_PKCS11_ID}"} \
      --read-object --type privkey --login \
    | openssl pkey -inform DER ${OPT_OPENSSL}
    ;;


  'pkcs11-pub')
    # shellcheck disable=2086
    pkcs11-tool \
      ${OPT_PKCS11_TOKEN:+--token-label "${OPT_PKCS11_TOKEN}"} \
      ${OPT_PKCS11_OBJECT:+--label "${OPT_PKCS11_OBJECT}"} \
      ${OPT_PKCS11_ID:+--id "${OPT_PKCS11_ID}"} \
      --read-object --type pubkey \
    | openssl pkey -pubin -inform DER ${OPT_OPENSSL}
    ;;


  'pkcs11-cert')
    # shellcheck disable=2086
    pkcs11-tool \
      ${OPT_PKCS11_TOKEN:+--token-label "${OPT_PKCS11_TOKEN}"} \
      ${OPT_PKCS11_OBJECT:+--label "${OPT_PKCS11_OBJECT}"} \
      ${OPT_PKCS11_ID:+--id "${OPT_PKCS11_ID}"} \
      --read-object --type cert \
    | openssl x509 -inform DER ${OPT_OPENSSL}
    ;;


  'pkcs11-test')
    # shellcheck disable=2086
    pkcs11-tool \
      ${OPT_PKCS11_TOKEN:+--token-label "${OPT_PKCS11_TOKEN}"} \
      ${OPT_PKCS11_OBJECT:+--label "${OPT_PKCS11_OBJECT}"} \
      ${OPT_PKCS11_ID:+--id "${OPT_PKCS11_ID}"} \
      --test --login
    ;;


  'pkcs11-uri')
    echo "${OPT_PKCS11_URI}"
    ;;



  ########################################################################
  # (nope...)
  #
  *)
    _ERROR "Invalid command" && exit 1

esac


## DONE!
exit 0
